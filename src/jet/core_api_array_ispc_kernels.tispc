// Copyright (c) 2017 Doyub Kim
//
// I am making my contributions/submissions to this project solely in my
// personal capacity and am not conveying any rights to any intellectual
// property of any third parties.

#begin_template
export void copyKernelS_$0(const uniform $1 a, uniform size_t n,
                           uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a; }
}
#end_template

#begin_template
export void copyKernelV_$0(const uniform $1 a[], uniform size_t n,
                           uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a[i]; }
}
#end_template

//

#begin_template
export void addKernelS_$0(const uniform $1 a, const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a + b[i]; }
}
#end_template

#begin_template
export void addKernelV_$0(const uniform $1 a[], const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a[i] + b[i]; }
}
#end_template

//

#begin_template
export void subKernelS_$0(const uniform $1 a, const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a - b[i]; }
}
#end_template

#begin_template
export void subKernelV_$0(const uniform $1 a[], const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a[i] - b[i]; }
}
#end_template

//

#begin_template
export void mulKernelS_$0(const uniform $1 a, const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a * b[i]; }
}
#end_template

#begin_template
export void mulKernelV_$0(const uniform $1 a[], const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a[i] * b[i]; }
}
#end_template

//

#begin_template
export void divKernelS_$0(const uniform $1 a, const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a / b[i]; }
}
#end_template

#begin_template
export void divKernelV_$0(const uniform $1 a[], const uniform $1 b[],
                          uniform size_t n, uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a[i] / b[i]; }
}
#end_template

//

#begin_template
export void axpyKernelS_$0(uniform $1 a, const uniform $1 x[],
                           const uniform $1 y[], uniform size_t n,
                           uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a * x[i] + y[i]; }
}
#end_template

#begin_template
export void axpyKernelV_$0(const uniform $1 a[], const uniform $1 x[],
                           const uniform $1 y[], uniform size_t n,
                           uniform $1 result[]) {
    foreach (i = 0 ... n) { result[i] = a[i] * x[i] + y[i]; }
}
#end_template

//

#begin_template
export void padEdge1_$0(uniform $1 p[], uniform size_t n,
                        uniform size_t padLeft, uniform size_t padRight) {
    $1 valLeft = p[padLeft];
    foreach (i = 0 ... padLeft) { p[i] = valLeft; }

    $1 valRight = p[n - padRight - 1];
    foreach (i = n - padRight - 1 ... n) { p[i] = valRight; }
}
#end_template

#begin_template
export void padEdge2_$0(uniform $1 p[], uniform size_t w, uniform size_t h,
                        uniform size_t padLeft, uniform size_t padRight,
                        uniform size_t padBottom, uniform size_t padTop) {
    // i
    foreach (j = padBottom... h - padTop) {
        $1* row = p + j * w;

        const $1 valLeft = row[padLeft];
        for (size_t i = 0; i < padLeft; ++i) {
            row[i] = valLeft;
        }

        const $1 valRight = row[w - padRight - 1];
        for (size_t i = w - padRight; i < w; ++i) {
            row[i] = valRight;
        }
    }

    // j
    const $1* rowBottom = p + padBottom * w;
    foreach (j = 0 ... padBottom) {
        $1* row = p + j * w;
        for (size_t i = 0; i < w; ++i) {
            row[i] = rowBottom[i];
        }
    }

    const $1* rowTop = p + (padTop - 1) * w;
    foreach (j = padTop... h - padTop) {
        $1* row = p + j * w;
        for (size_t i = 0; i < w; ++i) {
            row[i] = rowTop[i];
        }
    }
}
#end_template

#begin_template
export void padEdge3_$0(uniform $1 p[], uniform size_t w, uniform size_t h,
                        uniform size_t d, uniform size_t padLeft,
                        uniform size_t padRight, uniform size_t padBottom,
                        uniform size_t padTop, uniform size_t padBack,
                        uniform size_t padFront) {
    // i
    foreach (k = padBack... d - padFront) {
        for (size_t j = padBottom; j < h - padTop; ++j) {
            $1* row = p + (j + k * h) * w;

            const $1 valLeft = row[padLeft];
            for (size_t i = 0; i < padLeft; ++i) {
                row[i] = valLeft;
            }

            const $1 valRight = row[w - padRight - 1];
            for (size_t i = w - padRight; i < w; ++i) {
                row[i] = valRight;
            }
        }
    }

    // j
    foreach (k = padBack... d - padFront) {
        const $1* rowBottom = p + (padBottom + k * h) * w;
        for (size_t j = 0; j < padBottom; ++j) {
            $1* row = p + (j + k * h) * w;
            for (size_t i = 0; i < w; ++i) {
                row[i] = rowBottom[i];
            }
        }

        const $1* rowTop = p + (padTop - 1 + k * h) * w;
        for (size_t j = padTop; j < h - padTop; ++j) {
            $1* row = p + (j + k * h) * w;
            for (size_t i = 0; i < w; ++i) {
                row[i] = rowTop[i];
            }
        }
    }

    // k
    foreach (k = 0 ... padBack) {
        for (size_t j = 0; j < h; ++j) {
            $1* row = p + (j + k * h) * w;
            $1* rowBack = p + (j + padBack * h) * w;
            for (size_t i = 0; i < w; ++i) {
                row[i] = rowBack[i];
            }
        }
    }

    foreach (k = d - padFront... padFront) {
        for (size_t j = 0; j < h; ++j) {
            $1* row = p + (j + k * h) * w;
            $1* rowFront = p + (j + (padFront - 1) * h) * w;
            for (size_t i = 0; i < w; ++i) {
                row[i] = rowFront[i];
            }
        }
    }
}
#end_template